go test -bench=. -benchmem -benchtime=5s -cpuprofile cpu.out ./internal/service
|
|__goos: darwin
goarch: amd64
pkg: L4.5/internal/service
cpu: Intel(R) Core(TM) i5-7267U CPU @ 3.10GHz
BenchmarkGetStatsSmall-4        17681145               304.7 ns/op           144 B/op            2 allocs/op
BenchmarkGetStatsBig-4               428          16130518 ns/op         2007303 B/op            2 allocs/op
PASS
ok      L4.5/internal/service   19.006s


go tool pprof cpu.out
|
|__File: service.test
Type: cpu
Time: 2025-12-10 13:51:12 MSK
Duration: 18.26s, Total samples = 14.48s (79.31%)
Entering interactive mode (type "help" for commands, "o" for options)
(pprof)
|
|__top
        |
        |__Showing nodes accounting for 10420ms, 71.96% of 14480ms total
Dropped 123 nodes (cum <= 72.40ms)
Showing top 10 nodes out of 92
      flat  flat%   sum%        cum   cum%
    3420ms 23.62% 23.62%     4210ms 29.07%  slices.partitionOrdered[go.shape.float64]
    2070ms 14.30% 37.91%     2070ms 14.30%  runtime.kevent
    1070ms  7.39% 45.30%     1140ms  7.87%  runtime.nanotime1
     900ms  6.22% 51.52%      940ms  6.49%  cmp.Less[go.shape.float64] (inline)
     710ms  4.90% 56.42%      810ms  5.59%  runtime.walltime
     650ms  4.49% 60.91%      650ms  4.49%  runtime.pthread_cond_wait
     490ms  3.38% 64.30%     9940ms 68.65%  L4.5/internal/service.(*Statistic).GetStats
     410ms  2.83% 67.13%      470ms  3.25%  slices.insertionSortOrdered[go.shape.float64]
     380ms  2.62% 69.75%      380ms  2.62%  runtime.pthread_kill
     320ms  2.21% 71.96%      320ms  2.21%  runtime.madvise

-----!!!Пояснение!!!-----
После замены рекурсивного quickSort на встроенную функцию sort.Float64s профилирование показало следующие улучшения:
  -  рекурсивная функция quickSort исчезла из CPU-профиля 
  - ранее она занимала до 33% времени сервера
  - теперь встроенный алгоритм Go оптимизирован и не создаёт лишние слайсы
  - сильное снижение нагрузки на память
  - runtime.growslice больше не доминирует (раньше 23% CPU уходило на перераспределение слайсов)
  - уменьшились копирования (runtime.memmove) — память используется значительно эффективнее
 - сортировка стала основной, но более лёгкой операцией

Общее время работы сервиса сократилось

Благодаря встроенной сортировке скорость обработки больших массивов увеличилась примерно в 5–10 раз, особенно заметно на нагрузочных бенчмарках.

