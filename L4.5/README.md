 ## HTTP-сервис 
 HTTp-сервис, принимающий массив чисел и возращающий агрегированные статистики: сумма, среднее значение, медиана, отсортированный слайс и количество элементов.  
 Историю по созданию и оптимизации сервиса можно отследить по коммитам на гитхабе в директории проекта  
 В сервисном слое намеренно оставлена закоменченная реализация неоптимального варианта функции сортировки входных данных

## Релизация
Модель: Numbers (входной массив), Response (агрегированные данные)  
Сервис: GetStats — считает сумму, среднее, медиану, сортирует массив  
Router + Handler: POST /stats  
Сервер: адрес берется из .env  
Профилировка: включён pprof (/debug/pprof) для CPU и памяти  

## Первичная профиллировка (с функцией quickSort)
 реализация собственной рекурсивной функции quickSort
 Топовые функции cpu-профиля:
 ```
Функция	    CPU % (cum)	  Примечание
quickSort	33.46%	      Рекурсивная сортировка создаёт много слайсов и аллокаций
growslice	23.20%	      Постоянное расширение слайсов через append
memmove	    8.47%	      Копирование массивов при append
madvise 
/ kevent 
/ pthread_*  ~20%         Системные вызовы, не критично
```
Вывод:  
Основная проблема — рекурсивная функция quickSort с append → realloc → memmove  
Решение — перейти на стандартную сортировку sort.Float64s

Подробная информация по тесту находитмся в текстовм файле bench_tests1.txt в корневой директории


## Оптимизация
Встроенная сортировка  
Изменение: замена рекурсивной функции quickSort на функцию из стандартного пакета sort.Float64s
```
sorted := make([]float64, len(nums.Data))
copy(sorted, nums.Data)
sort.Float64s(sorted)
```
Убраны рекурсивные append и лишние аллокации.  
Сортировка теперь оптимизирована на уровне Go runtime.  

## Результаты CPU-профиля после оптимизации:
```
Функция	               CPU % (cum)	           Примечание
sort.Float64s / 
slices.partitionOrdered	 ~29%	             Встроенная сортировка, основной потребитель CPU
cmp.Less	             6.5%	             Сравнения float64
insertionSortOrdered	  3%	             Вставки для маленьких сегментов
Остальные	             ~33%	             Арифметика, обработка массива                   
```

Вывод:
QuickSort и growslice исчезли из топа.   
Скорость обработки массивов 250 000 элементов увеличилась в ~5–10 раз.   
Память используется значительно эффективнее.

Подробная информация по тесту находитмся в текстовм файле bench_tests.txt в корневой директории

## Trace-анализ
Trace собран с помощью:
go test -bench=. -benchmem -benchtime=5s -trace trace.out ./internal/service  

go tool trace trace.out

Timeline: основная горутина занята обработкой POST /stats. 
CPU: большая часть времени уходит на sort.Float64s и арифметику  
Блокировки / горутины: минимальны, нет утечек.

Вывод:  
Сервис работает эффективно, все узкие места устранены.   
Встроенная сортировка обеспечивает высокую производительность и низкие аллокации.

Подробная информация по тесту находится в текстовм файле trace_info.txt в корневой директории

## Вывод по проекту

Реализован сервис с POST /stats.

- Выявлено узкое место (quickSort) с помощью pprof.  
- Произведена оптимизация через встроенную сортировку sort.Float64s.  
- Проверено с помощью bencmarks, pprof и trace.  
- Сервис стал быстрее, использует меньше памяти, CPU распределяется эффективно.

